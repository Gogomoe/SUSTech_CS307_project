# 数据库设计

我觉得这次数据库里最复杂的就是查余票和购票两个方面。

首先有一点是，为了效率，我觉得数据库需要分层。例如把车的数据分为历史数据、近三天车的数据、三天后的数据（假设绝大多数的车都在开车前14天放票，那就是3-14天内的数据）。这里每个类别的数据关注点是不一样的。

### 历史数据

历史数据专门存几张表内，绝大多数情况下，这张表只需要提供查询。

并且历史数据的一些信息是没有意义的，例如我们通常不会去关注过去的某一车次的余票数是多少。因此在数据库的设计中，我们只需要订单表就能存下所有信息，不需要考虑余票数这些为了提高性能设计的冗余数据。

### 活跃数据（近3天数据）

活跃数据也专门存在几张表，这部分数据可能需要查询、插入、修改最频繁的数据，因此把数据范围限定在几天内，可以减少表的数据量，提高性能。

绝大多数操作都可以通过简单的SQL命令查询到结果，但是有几个操作可能涉及到复杂执行，比如余票和出票。

对于复杂的操作，考虑使用 redis 进行缓存提高效率，每次系统启动时，根据数据库内的数据生成对应的 redis 的存储结构，并定时进行同步。

#### 余票系统

首先要考虑的是，如果简单的用 int 存储各个原子区间的余票数，实际上并不能完全表现座位剩余的情况。考虑区间 `A-B-C` 如果 `A-B` 有一张余票，`B-C`有一张余票，这两个区间剩余的座位可能并不是同一个座位，因此 `A-C` 可能有余票，也可能没有。

如何解决这个问题，我们可以尝试存每个子区间的余票。比如 `A-B-C-D-E` 长度为 1 的区间有4个，长度为2的区间有3个，等等。对每个区间都存下余票信息，n个站点会有 n-1 个原子区间，就会产生 $ \frac{n(n-1)}{2}$ 个区间。

如果购买一张 `B-D` 的车票，计算余票数可以这样考虑，对于每个与 `B-D` 有重合的区间票数减 1 。`B-D`的子区间有 `B-D`, `B-C`, `C-D`, 包含 `B-D` 的区间有`A-D`,`B-E`,`A-E`，部分重合的区间有 `A-C`,`C-E`。换个角度考虑，如果一个座位在 `B-D` 被占用，那么不重合的`A-B`,`D-E`可以重复利用。==TODO：验证这个算法是正确的==

由于区间的数量是 $O(n^2)$ 的，因此这个操作的时间复杂度是 $O(n^2)$ 的。考虑绝大多数车次站点数都不是很长，最多站点的车次按 n = 80 计算，每次操作需要花费 $6400$ 时钟周期，能在一毫秒内完成。由于绝大多数的车次并不会有那么多站点，并且查询余票数量的情况远远多于出票的情况，因此这个采用这个存储结构的时间消耗查询 $O(1)$，出票$O(n^2)$是可以接受的。

对于空间消耗，假设每日有 10000 车次，平均每个车次有 30 个站点，余票数使用 4字节Int 存，活跃数据（3天）需要存储 $3天*10000车次/天*\frac{30*30}{2}*4bytes=54MB$ ，这样的内存消耗是可以接受的。

当然这个算法是存在问题的，可能会出现仍有座位但是却没有余票的情况。考虑分别买了 `A-B` , `B-C` 两张票，分配座位时重复利用了同一个座位，但是区间`A-C`的余票却重复减了两次，这导致 `A-C` 的余票数可能小于实际上能乘坐的数量。解决这个方法是，定期进行一次同步，根据实际的座位算出来真实的余票数，或者购买车票时就根据座位信息减去真实的余票数量。

#### 出票系统

出票系统需要找到一个符合条件的座位号，如果找不到则是无法出票。

我们可以使用一个简单的 座位数*原子区间数 的 boolean 数组，对于每张票，我们将对应的座位 id 中的每个原子区间设为占用。出票时找到一个座位，如果它在对应区间内都是可用的，那这个座位就可以被使用，出票成功。

假设座位数和站点数最多的车次有3000个座位，有80个站点，那就是 240000 时钟周期，大概也能在几毫秒内完成，可以接受。

对于空间消耗，假设每日有 10000 车次，平均每个车次有 30 个站点和1000个座位，每个座位的 boolean 使用1个字节存储，那么需要存储 $3天*10000车次/天*30站*1000座位*1byte=900MB$。电脑居然装得下，那就全存内存里吧。

#### 余票同步

余票同步有两个步骤，一是根据数据库里的订单信息，生成出票系统使用的座位区间占用信息。二是根据作为区间信息，生成余票信息。为表述方便，令 $M=座位数=1000$，$N=站点数=30$

生成座位区间占用信息较为简单，从数据库中获取对应的订单后，把该订单的座位对应的区间设为占用即可，这个步骤在 $O(M*N)$ 内可以完成，预测几毫秒内能完成一个车次的数据生成。

根据座位占用信息生成余票信息，对于每个座位的每个连续未占用区间，花费 $O(N^2)$ 时间生成每个子区间对应的余票。但实际上多个不连续的未占用区间，生成的区间数不会超过$O(N^2)$ ，因此每个座位生成信息花费的时间为 $ O(N^2) $，对于一个车次所有座位花费 $O(M*N^2)$ ，约为几十毫秒。

数据库IO和redis IO预估值也为几十毫秒，那么完成一次余票同步可能需要200ms才能完成，完成10000车次的余票同步需要30分钟。

另外，出票时更新余票，可以先减去其原本对各个区间贡献的余票数，然后再加上出票后仍然贡献的余票数，以此计算出真正的余票数量，减少余票信息同步。